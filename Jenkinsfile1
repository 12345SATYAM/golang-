import net.sf.json.JSONObject;
import net.sf.json.JSONArray;
import groovy.json.JsonOutput
import groovy.json.*

pipeline {
    environment {
        FAILED_AT_STAGE = 'NONE'
        SONAR_IN_USE = "central-sonar-01"
        BB_PR_LINK = "https://bitbucket.org/paytmteam/" + "${BB_REPO_NAME}" + "/pull-requests/" + "${BB_PR_ID}"
        BB_AUTHOR_INFO = 'NA'
        //SONAR_DASHBOARD_LINK = "https://${SONAR_IN_USE}.paytmdgt.io/dashboard?id=" + "${BB_REPO_NAME}"
        QG_STATUS = 'UNKNOWN'
        TEST_ENABLED = 'true'
        TEST_FAILURE_IGNORE = 'false'
        SONAR_ENABLED = 'true'
        TRUTH_BRANCH_EXECUTION = 'false'
    }
    agent {
        docker {
            image '698979518480.dkr.ecr.ap-south-1.amazonaws.com/go:1.17.3'
            label 'linux'
            args '--net=host'
        }
    }
    options {
        timeout(time: 2, unit: 'HOURS')
        timestamps()
    }
    stages {
        stage('Checkout') {
            steps {
                readParams()
                println "Checkout....."
                goCheckoutVerify()
            }
        }
        stage('Requirement Setup'){
            steps{
                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE'){
                   println "Installing Requirements..."
                   installingRequirements()
                }
            }
        }
        stage('Compile'){
            steps{
                   println "Compile..."
                   goBuild()
            }
        }
        stage('Go Lint'){
            steps{
                   println "Go lint..."
                   goLint()
            }
        }
        stage('Unit Tests'){
            when {
                expression { return TEST_ENABLED == 'true'}
            }
            steps{
                   println "Unit Tests..."
                   goTest()
            }
        }
        stage('Coverage Report'){
            when {
                expression { return TEST_ENABLED == 'true'}
            }
            steps{
                   println "Coverage Report..."
                   coverageReport()
            }
        }
        stage('Sonar Analysis') {
            when {
                expression { return SONAR_ENABLED == 'true' }
            }
            steps{
                println "Sonar Analysis.."
                sonarAnalysis()
            }
        }
        stage('Quality Gate'){
            when {
                expression { return SONAR_ENABLED == 'true' }
            }
            steps{
                script{
                    FAILED_AT_STAGE = 'Quality Gate'
                    timeout(time: 1, unit: 'HOURS') {
                        def qg = waitForQualityGate()
                        QG_STATUS = qg.status
                        if (qg.status == 'ERROR') {
                            println "Pipeline QG FAILED: ${qg.status}"
                        }
                        if (qg.status == 'OK') {
                            println "Pipeline QG SUCCESS: ${qg.status}"
                        }
                        FAILED_AT_STAGE = 'UNKNOWN'
                    }
                }
            }
        }
    }
    post {
        failure {
            println "Failed Slack Notification Trigger....."
            slackNotifyFailure()

        }
        always {
            println "Setting 'FAILED_AT_STAGE' Parameter...."
            setVariables()
            println "Making a POST Call to Controller...."
            postCallController()
        }
    }
}

def readParams() {
    println "Additional Parameters.........."
    println "${ADDITIONAL_PARAMS}"
    process = ADDITIONAL_PARAMS
    def json_output = new JsonSlurper().parseText(process)
    println json_output

    if ( "${json_output['sonar.enabled']}" == 'false') {
        SONAR_ENABLED = 'false'
    }
    if ( "${json_output['maven.test.execution.enabled']}" == 'true') {
        TEST_ENABLED = 'true'
    }
    if (json_output.keySet().contains('test_execution_framework')) {
        TEST_FRAMEWORK = "${json_output['test_execution_framework']}"
    }

    println "TEST_ENABLED - ${TEST_ENABLED}"
    println "TEST_FAILURE_IGNORE - ${TEST_FAILURE_IGNORE}"
    println "SONAR_ENABLED - ${SONAR_ENABLED}"

    SONAR_IN_USE = "${json_output['sonar.env']}"
    BB_AUTHOR_INFO = "${json_output['bitbucket.author.info']}"

    println "SONAR_IN_USE - ${SONAR_IN_USE}"
    println "BB_AUTHOR_INFO - ${BB_AUTHOR_INFO}"

    if ( "${json_output['truth_branch_execution']}" == 'true') {
        TRUTH_BRANCH_EXECUTION = 'true'
    }

    println "TRUTH_BRANCH_EXECUTION - ${TRUTH_BRANCH_EXECUTION}"
}

def goCheckoutVerify() {
    FAILED_AT_STAGE = 'Checkout'
    currentBuild.displayName = currentBuild.displayName + ": ${BB_REPO_NAME}"
    currentBuild.description = "Branch: ${BB_SOURCE_BRANCH}\nPR Description: ${BB_PR_DESC}\nPR Link: ${BB_PR_LINK}"
    cleanWs deleteDirs: true, notFailBuild: true, patterns: [[pattern: 'tmp/**', type: 'EXCLUDE']]
    checkout([$class: 'GitSCM', branches: [[name: '*/${BB_SOURCE_BRANCH}']], doGenerateSubmoduleConfigurations: false, extensions: [[$class: 'CloneOption', depth: 0, noTags: true, reference: '', shallow: true, timeout: 5]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'bitbucketUser', url: 'git@bitbucket.org:paytmteam/${BB_REPO_NAME}.git']]])
}

def installingRequirements() {
    FAILED_AT_STAGE = 'Requirement Setup'
    withEnv(["HOME=${env.WORKSPACE}"]) {
        withCredentials([sshUserPrivateKey(credentialsId: 'bitbucketUser', keyFileVariable: 'gitclone')]) {
                sh "ssh-keyscan -t rsa bitbucket.org >> /home/jenkins/.ssh/known_hosts"
                sh("ssh-agent && eval `ssh-agent -s` && ssh-add ${gitclone} && go mod download")
        }
    }
}

def goBuild() {
        FAILED_AT_STAGE = 'Compile'
         withEnv(["HOME=${env.WORKSPACE}"]) {
            sh "go build -v"
         }
}

def goLint(){
  FAILED_AT_STAGE = 'Go Lint'
         withEnv(["HOME=${env.WORKSPACE}"]) {
            sh "golangci-lint run -v"
         }
}

def goTest() {
        FAILED_AT_STAGE = 'Unit Tests'
         withEnv(["HOME=${env.WORKSPACE}"]) {
            sh "go test ./... -v"
         }
}

def coverageReport() {
        FAILED_AT_STAGE = 'Coverage Report'
          sh "touch coverage.out"
          withEnv(["HOME=${env.WORKSPACE}"]) {
                sh 'go test -coverprofile=coverage.out ./...'
          }
}

def sonarAnalysis() {
    if (TEST_ENABLED == 'true') {
        withSonarQubeEnv("${SONAR_IN_USE}") {
             sh 'sonar-scanner -Dsonar.projectName=${BB_REPO_NAME} -Dsonar.projectKey=${BB_REPO_NAME} -Dsonar.branch.name=${BB_SOURCE_BRANCH} -Dsonar.go.coverage.reportPaths=coverage.out -Dsonar.sourceEncoding=UTF-8'
        }
    }
    if (TEST_ENABLED == 'false'){
        withSonarQubeEnv("${SONAR_IN_USE}") {
             sh 'sonar-scanner -Dsonar.projectName=${BB_REPO_NAME} -Dsonar.projectKey=${BB_REPO_NAME} -Dsonar.branch.name=${BB_SOURCE_BRANCH} -Dsonar.sourceEncoding=UTF-8'
        }
    }
}

def setVariables() {
    if ("${currentBuild.currentResult}" == "SUCCESS") {
        FAILED_AT_STAGE = 'NONE'
    }
}

def postCallController() {
    def detailed_rep = JsonOutput.prettyPrint(JsonOutput.toJson ([failed_stage: "${FAILED_AT_STAGE}"]))
    def report_text = new JsonSlurperClassic().parseText(detailed_rep)
    sh "git log refs/remotes/origin/${BB_DESTINATION_BRANCH}..refs/remotes/origin/${BB_SOURCE_BRANCH} --pretty=format:'%ce' > emaillist"
    def authors = readFile('emaillist').readLines()
    def author_email = []
    for (item in authors){
        author_email.add(item)
    }
    author_email = author_email.unique()
    def json_text = JsonOutput.prettyPrint(JsonOutput.toJson ([project_name: "${BB_PROJECT_NAME}", repo_name: "${BB_REPO_NAME}", event_id: "${BB_PR_ID}", commit_id: "${GIT_COMMIT_ID}", job_status: "${currentBuild.currentResult}", qg_status: "${QG_STATUS}", truth_branch_execution: "${TRUTH_BRANCH_EXECUTION}", detailed_report: report_text, jenkins_job_url: "${env.BUILD_URL}", job_type: "go", author_email: author_email]))
    println json_text
    sh "curl -X POST -i 'https://itl-cp.paytmdgt.io/paytm/centralpipeline/v1/controller/status/update' --header 'Content-Type: application/json' --data '$json_text'"
}

def slackNotifyFailure() {

    channelSlack = 'paytm-central-pipeline-alerts'

    println "Sending Slack Notifation........."

    buildStatus = currentBuild.currentResult
    colorCode = 'danger'

    subject = "Central Pipeline Execution Failure"

    JSONObject attachment = new JSONObject();
    attachment.put('author',"jenkins");
    attachment.put('color', colorCode);
    attachment.put('mrkdwn_in', ["fields"])

    JSONObject repo = new JSONObject();
    repo.put('title', 'Repo Name');
    repo.put('value', "${BB_REPO_NAME}".toString());

    JSONObject source_branch = new JSONObject();
    source_branch.put('title', 'Source Branch');
    source_branch.put('value', "${BB_SOURCE_BRANCH}".toString());

    JSONObject destination_branch = new JSONObject();
    destination_branch.put('title', 'Destination Branch');
    destination_branch.put('value', "${BB_DESTINATION_BRANCH}".toString());

    JSONObject pr_details = new JSONObject();
    pr_details.put('title', 'PR Description');
    pr_details.put('value', "${BB_PR_DESC}".toString());

    JSONObject pr_link = new JSONObject();
    pr_link.put('title', 'PR Link');
    pr_link.put('value', "${env.BB_PR_LINK}".toString());

    JSONObject author_name = new JSONObject();
    author_name.put('title', 'Author Info');
    author_name.put('value', "${BB_AUTHOR_INFO}".toString());

    JSONObject job_link = new JSONObject();
    job_link.put('title', 'Job Link');
    job_link.put('value', "${env.BUILD_URL}".toString());

    JSONObject failed_at = new JSONObject();
    failed_at.put('title', 'Analysis Failed At');
    failed_at.put('value', "${FAILED_AT_STAGE}".toString());

    attachment.put('fields', [repo, source_branch, destination_branch, pr_details, pr_link, author_name, job_link, failed_at]);

    JSONArray attachments = new JSONArray();
    attachments.add(attachment);

    slackSend channel: channelSlack, color: colorCode, message: subject, attachments: attachments.toString(), tokenCredentialId: 'slackToken', username: 'Paytm Central Pipeline'
}
